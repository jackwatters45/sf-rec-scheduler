Architecture and setup process:

1. **Backend API (FastAPI)**
```python
# Example structure for your FastAPI application
src/
├── api/
│   ├── __init__.py
│   ├── main.py           # FastAPI app entry point
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── reservations.py
│   │   ├── users.py
│   │   └── settings.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── reservation.py
│   │   ├── user.py
│   │   └── settings.py
│   └── services/
│       ├── __init__.py
│       ├── reservation_service.py  # Your existing bot logic
│       └── scheduler_service.py    # Scheduler functionality
├── database/
│   └── models.py         # Database models (SQLAlchemy)
└── config.py            # Configuration management
```

2. **Example FastAPI Endpoints**
```python
# src/api/routers/reservations.py
from fastapi import APIRouter, Depends
from typing import List
from ..models.reservation import ReservationCreate, ReservationResponse
from ..services.reservation_service import ReservationService

router = APIRouter()

@router.post("/reservations/schedule", response_model=ReservationResponse)
async def schedule_reservation(
    reservation: ReservationCreate,
    service: ReservationService = Depends()
):
    """Schedule a new reservation"""
    return await service.create_reservation(reservation)

@router.get("/reservations", response_model=List[ReservationResponse])
async def get_reservations(
    service: ReservationService = Depends()
):
    """Get all reservations for the authenticated user"""
    return await service.get_user_reservations()
```

3. **Frontend Application**
You could use any modern JavaScript framework (React, Vue, Svelte). Here's a basic React structure:
```
frontend/
├── src/
│   ├── components/
│   │   ├── ReservationForm.tsx
│   │   ├── ReservationList.tsx
│   │   └── Settings.tsx
│   ├── services/
│   │   └── api.ts        # API client
│   ├── types/
│   │   └── index.ts      # TypeScript types
│   └── App.tsx
├── package.json
└── vite.config.ts        # Using Vite for build
```

4. **Authentication**
You'll need to add authentication to protect the API:
```python
# src/api/auth.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from ..models.user import User

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        return await get_user(username)
    except JWTError:
        raise credentials_exception
```

5. **Database Integration**
```python
# src/database/models.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from .database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    reservations = relationship("Reservation", back_populates="user")

class Reservation(Base):
    __tablename__ = "reservations"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    field = Column(String)
    time = Column(DateTime)
    status = Column(String)
    user = relationship("User", back_populates="reservations")
```

6. **Configuration Management**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    class Config:
        env_file = ".env"

settings = Settings()
```

To implement this:

1. First, restructure your current bot code into a service that can be called by the API:
   - Move the core reservation logic into a service class
   - Make it configurable per user
   - Add proper error handling and status reporting

2. Create the FastAPI application:
```bash
pip install fastapi uvicorn sqlalchemy alembic python-jose[cryptography] passlib[bcrypt]
```

3. Set up the frontend:
```bash
npm create vite@latest frontend -- --template react-ts
cd frontend
npm install axios @tanstack/react-query
```

4. Development workflow:
```bash
# Run API in development
uvicorn src.api.main:app --reload

# Run frontend in development
cd frontend
npm run dev
```

This setup gives you:
- RESTful API with FastAPI
- Type safety with Pydantic models
- Database persistence with SQLAlchemy
- Authentication and user management
- Modern frontend with React
- API documentation with Swagger UI (automatically generated by FastAPI)

Would you like me to expand on any particular aspect of this setup?
